
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Baseline Algorithm Definition &#8212; CIMR L2 Sea Ice Drift ATBD v1</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/watermark.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Algorithm Input and Output Data Definition (IODD)" href="algorithm_input_output_data_definition.html" />
    <link rel="prev" title="Level-2 product definition" href="L2_product_definition.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.jpg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">CIMR L2 Sea Ice Drift ATBD v1</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    CIMR L2 Sea Ice Drift ATBD
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="abstract.html">
   Abstract
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="applicable_ref_docs.html">
   Applicable and Reference Documents
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="acronyms.html">
   Acronyms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="definitions.html">
   Definitions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="introduction_purpose_scope.html">
   Introduction, purpose and scope
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="background_justification_algorithm.html">
   Background and justification of selected algorithm
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L2_product_definition.html">
   Level-2 product definition
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Baseline Algorithm Definition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="algorithm_input_output_data_definition.html">
   Algorithm Input and Output Data Definition (IODD)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="references.html">
   References
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>
<a href="https://github.com/CIMR-Algos/SeaIceDrift_ATBD"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="bottom"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/baseline_algorithm_definition.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cimr-level-1b-re-sampling-approach">
   CIMR Level-1b re-sampling approach
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algorithm-assumptions-and-simplifications">
   Algorithm Assumptions and Simplifications
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#level-2-end-to-end-algorithm-functional-flow-diagram">
   Level-2 end to end algorithm functional flow diagram
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#functional-description-of-each-algorithm-step">
   Functional description of each Algorithm step
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pre-processing">
     Pre-processing
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#prepare-ice-ocean-land-mask">
       Prepare ice/ocean/land mask
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#input-data">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#output-data">
         Output data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#auxiliary-data">
         Auxiliary data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#remap-level-1b-brightness-temperatures-to-the-ease2-image-grids">
       Remap Level-1b brightness temperatures to the EASE2 image grids
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#mathematical-description">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id1">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id2">
         Output data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#ancillary-data">
         Ancillary data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#image-preprocessing-laplacian-filter">
       Image preprocessing (Laplacian filter)
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id3">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id6">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id7">
         Output data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id8">
         Ancillary data
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sea-ice-motion-tracking">
     Sea-ice motion tracking
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#select-grid-locations-where-to-apply-the-cmcc-algorithm">
       Select grid locations where to apply the CMCC algorithm
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#logical-description">
         Logical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id10">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id11">
         Output data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#run-the-cmcc-algorithm">
       Run the CMCC algorithm
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id12">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id16">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id17">
         Output data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#quality-control-detect-and-correct-outliers-rogue-vectors">
       Quality Control: detect and correct outliers (“rogue” vectors)
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id18">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id19">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id20">
         Output data
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Baseline Algorithm Definition</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cimr-level-1b-re-sampling-approach">
   CIMR Level-1b re-sampling approach
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algorithm-assumptions-and-simplifications">
   Algorithm Assumptions and Simplifications
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#level-2-end-to-end-algorithm-functional-flow-diagram">
   Level-2 end to end algorithm functional flow diagram
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#functional-description-of-each-algorithm-step">
   Functional description of each Algorithm step
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pre-processing">
     Pre-processing
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#prepare-ice-ocean-land-mask">
       Prepare ice/ocean/land mask
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#input-data">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#output-data">
         Output data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#auxiliary-data">
         Auxiliary data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#remap-level-1b-brightness-temperatures-to-the-ease2-image-grids">
       Remap Level-1b brightness temperatures to the EASE2 image grids
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#mathematical-description">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id1">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id2">
         Output data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#ancillary-data">
         Ancillary data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#image-preprocessing-laplacian-filter">
       Image preprocessing (Laplacian filter)
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id3">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id6">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id7">
         Output data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id8">
         Ancillary data
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sea-ice-motion-tracking">
     Sea-ice motion tracking
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#select-grid-locations-where-to-apply-the-cmcc-algorithm">
       Select grid locations where to apply the CMCC algorithm
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#logical-description">
         Logical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id10">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id11">
         Output data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#run-the-cmcc-algorithm">
       Run the CMCC algorithm
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id12">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id16">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id17">
         Output data
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#quality-control-detect-and-correct-outliers-rogue-vectors">
       Quality Control: detect and correct outliers (“rogue” vectors)
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id18">
         Mathematical description
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id19">
         Input data
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id20">
         Output data
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="baseline-algorithm-definition">
<h1>Baseline Algorithm Definition<a class="headerlink" href="#baseline-algorithm-definition" title="Permalink to this headline">#</a></h1>
<p>In the following sections, the Level-2 sea-ice drift algorithm is further
described. It consists in those steps:</p>
<ul class="simple">
<li><p>resampling og Level-1b data;</p></li>
<li><p>selection of tracking locations and preliminary screening;</p></li>
<li><p>block-based maximisation of the correlation metric via the CMCC;</p></li>
<li><p>filtering and correction step;</p></li>
<li><p>assign status flags and per-vector uncertainties.</p></li>
</ul>
<p>Sea-ice motion tracking is performed at the intersection of two swaths. The motion tracking itself requires that the brightness temperature imagery
is first resampled to a common grid. This makes the level-2 sea-ice drift product quite different from other level-2 products in that:</p>
<ol class="simple">
<li><p>the Level-1b data must be remapped to a common (polar) grid as part of the processing, e.g. an EASE2 grid;</p></li>
<li><p>as a consequence, the Level-2 sea-ice drift product is presented on an EASE2 grid (not in a swath projection);</p></li>
<li><p>the algorithm operates not with one, but with at least <strong>two</strong> Level-1b files as input;</p></li>
<li><p>for each incoming Level-1b file, one can generate more than one Level-2 sea-ice drift product (consider the swath intersection with the most recent Level-1b swath, the one before, etc…)</p></li>
</ol>
<section id="cimr-level-1b-re-sampling-approach">
<h2>CIMR Level-1b re-sampling approach<a class="headerlink" href="#cimr-level-1b-re-sampling-approach" title="Permalink to this headline">#</a></h2>
<p>The re-sampling approach for resampling CIMR Level-1b Ku and Ka band imagery is not defined at this stage. From experience with sea-ice motion tracking from other passive
microwave mission, the Level-1b re-sampling approach does not have a large influence on the results. At this stage, the following characteristics are expected from the
re-sampling:</p>
<ol class="simple">
<li><p>Remap incoming Level-1b files on two EASE2 polar grids (one covering northern hemisphere, the other covering the southern hemisphere);</p></li>
<li><p>Remap 4 imagery channels (Ku-V, Ku-H, Ka-V, Ka-H);</p></li>
<li><p>Remap the forward and backward scans separately;</p></li>
<li><p>Aim at a grid spacing close to 5 km (TBC).</p></li>
</ol>
<p><a class="reference internal" href="#grids"><span class="std std-numref">Table 4</span></a> defines four grids, two for the northern hemisphere, two for the southern hemisphere. nx (ny) is the number of grid cells in x (y) dimension, Ax (Ay) is the grid spacing, and Cx (Cy) is the coordinate
of the upper-left corner of the upper-left cell in the grid. Grids <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-005</span></code> have 5 km grid spacing and are candidate target grids on which to remap the Level-1b imagery. Grids <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-250</span></code> have 25 km grid spacing
and are candidate grids for the resulting Level-2 sea-ice drift product. By construction, the center of the cells of the two ‘250’ grids fall exactly at the center of one every five grid cells of the ‘005’ grids. This
ensures that drift vectors (at every grid cell of the ‘250’ grids) use image blocks (from the ‘005’ grids) that are perfectly aligned.</p>
<table class="colwidths-auto table" id="grids">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Definition of EASE2 grids used in the Level-2 sea-ice drift processing (TBC)</span><a class="headerlink" href="#grids" title="Permalink to this table">#</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Id</p></th>
<th class="head"><p>nx</p></th>
<th class="head"><p>ny</p></th>
<th class="head"><p>Ax [km]</p></th>
<th class="head"><p>Ay [km]</p></th>
<th class="head"><p>Cx [km]</p></th>
<th class="head"><p>Cy [km]</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nh_ease2-250</span></code>, <code class="docutils literal notranslate"><span class="pre">sh_ease2-250</span></code></p></td>
<td><p>432</p></td>
<td><p>432</p></td>
<td><p>25.0</p></td>
<td><p>25.0</p></td>
<td><p>-5400.0</p></td>
<td><p>-5400.0</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">nh_ease2-005</span></code>, <code class="docutils literal notranslate"><span class="pre">sh_ease2-005</span></code></p></td>
<td><p>2160</p></td>
<td><p>2160</p></td>
<td><p>5.0</p></td>
<td><p>5.0</p></td>
<td><p>-5400.0</p></td>
<td><p>-5400.0</p></td>
</tr>
</tbody>
</table>
<p>Such a ‘1-every-5’ construct is not a requirement of the sea-ice drift algorithm, but a simplification used in many motion extraction algorithms. Other alternatives are to grid the Level-1b data with
4 km spacing and consider a ‘1-every-6’ ratio (Level-2 grid spacing at 24 km) or keep a ‘1-every-5’ ratio (Level-2 grid spacing at 20 km).</p>
<p>The remaining of the algorithm description does not depend on this choice, which can easily be changed in the course of the product development.</p>
<p>Each incoming Level-1b file thus results in 16 gridded fields of brightness temperature: 2 hemispheres x 2 scans x 4 bands. These can be written in two L1C-like netCDF files (1 per hemisphere) or
directly entered in the motion tracking algorithm. They must be written to netCDF files at one point so that they are available for sea-ice drift processing when the next Level-1b swath file arrives.</p>
</section>
<section id="algorithm-assumptions-and-simplifications">
<h2>Algorithm Assumptions and Simplifications<a class="headerlink" href="#algorithm-assumptions-and-simplifications" title="Permalink to this headline">#</a></h2>
<p>All block-based motion have similar assumptions and simplifications. They assume that each pixel in a block moves at a constant rate from one image to the next: what is retrieved are the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code>
components of the motion vector. In case of rotational motion within the area of the image block, the retrieved components will be those representing most faithfully the change in intensity between
the two images, but the rotation rate is not measured. By the same token, if deformation (convergence / divergence / shear) occurs within the area of the image blocks, this will not be detected.
Rotation and deformation betwen image blocks (between neighbouring pixels) can of course be detected.</p>
<p>To detect and possibly correct “rogue” vectors in the motion field, we have to assume that the motion field is spatially coherent in a neighbourhood. This is because we detect anomalous motion vectors
by their distance to the local average motion. One must be careful with this assumption as to not artificially smooth the motion fields and remove actual diverging / converging motion.</p>
</section>
<section id="level-2-end-to-end-algorithm-functional-flow-diagram">
<h2>Level-2 end to end algorithm functional flow diagram<a class="headerlink" href="#level-2-end-to-end-algorithm-functional-flow-diagram" title="Permalink to this headline">#</a></h2>
<p><a class="reference internal" href="#fig-flow-diagram"><span class="std std-numref">Fig. 3</span></a> shows the flow diagram for the CIMR Level-2 sea-ice drift algorithm. Note the structure in two chains: preprocessing of the image, and sea-ice motion tracking per se.</p>
<figure class="align-default" id="fig-flow-diagram">
<a class="reference internal image-reference" href="_images/CIMR_L2_Sea_Ice_Drift_Flow_Diagram.png"><img alt="_images/CIMR_L2_Sea_Ice_Drift_Flow_Diagram.png" src="_images/CIMR_L2_Sea_Ice_Drift_Flow_Diagram.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">End-to-end algorithm flow diagram of the CIMR Level-2 sea-ice drift algorithm</span><a class="headerlink" href="#fig-flow-diagram" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="functional-description-of-each-algorithm-step">
<h2>Functional description of each Algorithm step<a class="headerlink" href="#functional-description-of-each-algorithm-step" title="Permalink to this headline">#</a></h2>
<section id="pre-processing">
<h3>Pre-processing<a class="headerlink" href="#pre-processing" title="Permalink to this headline">#</a></h3>
<section id="prepare-ice-ocean-land-mask">
<h4>Prepare ice/ocean/land mask<a class="headerlink" href="#prepare-ice-ocean-land-mask" title="Permalink to this headline">#</a></h4>
<p>The Level-2 sea-ice drift algorithm shall only be applied over sea-ice portions of the image. We thus need to prepare an ice/ocean mask as well
as a land-mask to only process over sea ice.</p>
<section id="input-data">
<h5>Input data<a class="headerlink" href="#input-data" title="Permalink to this headline">#</a></h5>
<p>The latitude and longitude of the image grids <code class="docutils literal notranslate"><span class="pre">nh_ease2-005</span></code> and <code class="docutils literal notranslate"><span class="pre">sh_ease2-005</span></code>.</p>
</section>
<section id="output-data">
<h5>Output data<a class="headerlink" href="#output-data" title="Permalink to this headline">#</a></h5>
<p>A 2D field of ice/no-ice/land on the image grids.</p>
</section>
<section id="auxiliary-data">
<h5>Auxiliary data<a class="headerlink" href="#auxiliary-data" title="Permalink to this headline">#</a></h5>
<p>A source of sea-ice concentration (can be from CIMR Level-2 Sea Ice Concentration product, or Level-2 Integrated-Retrieval product).</p>
</section>
</section>
<section id="remap-level-1b-brightness-temperatures-to-the-ease2-image-grids">
<h4>Remap Level-1b brightness temperatures to the EASE2 image grids<a class="headerlink" href="#remap-level-1b-brightness-temperatures-to-the-ease2-image-grids" title="Permalink to this headline">#</a></h4>
<p>The Level-1b data (brightness temperature at Ku-V, Ku-H, Ka-V, Ka-H) are remapped onto the EASE2 image grids <code class="docutils literal notranslate"><span class="pre">nh_ease2-005</span></code> and <code class="docutils literal notranslate"><span class="pre">sh_ease2-005</span></code>. The forward and backward scans
are remapped independently.</p>
<p>A <em>valid time</em> is associated to the remapped imagery. It can be defined as the mean time of all the Level-1b samples remapped onto the image grid or the time of the observation closest to the (north or south pole).
The exact definition is not critical, neither is the accuracy, so that a single valid time is associated to all 8 remapped imagery bands in the northern hemisphere, and a single (different) time to the 8
remapped imagery bands i nthe southern hemisphere.</p>
<section id="mathematical-description">
<h5>Mathematical description<a class="headerlink" href="#mathematical-description" title="Permalink to this headline">#</a></h5>
<p>Remapping is the process of computing the Level-1b brightness temperature onto a regular Earth-based grid. The values in the image grid can generally be described as a weighted sum of
the values in the Level-1b swath projection. The mathematical description is TBD and will depend on the selected remapping strategy (TBD for v2 ATBD).</p>
</section>
<section id="id1">
<h5>Input data<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h5>
<p>The latitude and longitude of the image grids <code class="docutils literal notranslate"><span class="pre">nh_ease2-005</span></code> and <code class="docutils literal notranslate"><span class="pre">sh_ease2-005</span></code>.</p>
<p>The Level-1b brightness temperatures of all samples in the  input Level-1b file, splitted in a forward and a backward scan.</p>
</section>
<section id="id2">
<h5>Output data<a class="headerlink" href="#id2" title="Permalink to this headline">#</a></h5>
<p>16 2D field of brightness temperature on the image grids (2 grids x 2 scans x 4 channels).</p>
</section>
<section id="ancillary-data">
<h5>Ancillary data<a class="headerlink" href="#ancillary-data" title="Permalink to this headline">#</a></h5>
<p>The latitude and longitude of all the Level-1b samples.</p>
</section>
</section>
<section id="image-preprocessing-laplacian-filter">
<h4>Image preprocessing (Laplacian filter)<a class="headerlink" href="#image-preprocessing-laplacian-filter" title="Permalink to this headline">#</a></h4>
<p>The remapped brightness temperatures are not used direclty as input to the sea-ice motion tracking step. Instead, a filter is first applied to the remapped imagery to
enhance and stabilize intensity patterns.</p>
<p>At the end of the step, the laplacian processed imagery are saved to disk, e.g. in netCDF files (two separated files for the two hemispheres).</p>
<section id="id3">
<h5>Mathematical description<a class="headerlink" href="#id3" title="Permalink to this headline">#</a></h5>
<p>A common filter, used by <span id="id4">Girard-Ardhuin and Ezraty [<a class="reference internal" href="references.html#id7" title="Fanny Girard-Ardhuin and Robert Ezraty. Enhanced arctic sea ice drift estimation merging radiometer and scatterometer data. IEEE Transactions on Geoscience and Remote Sensing, 50(7):2639-2648, 2012. doi:10.1109/TGRS.2012.2184124.">2012</a>]</span> and <span id="id5">Lavergne <em>et al.</em> [<a class="reference internal" href="references.html#id19" title="Thomas Lavergne, Steinar Eastwood, Zakaria Teffah, Harald Schyberg, and Lars-Anders Breivik. Sea ice motion from low resolution satellite sensors: an alternative method and its validation in the Arctic. Journal of Geophysical Research, 2010. doi:10.1029/2009JC005958.">2010</a>]</span>, is the Laplace filter, that is based on computing the second derivatives of the image intensity.</p>
<div class="math notranslate nohighlight" id="equation-eq-laplace">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-laplace" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{split}
\mathcal{L}[i,j] &amp;= \frac{1}{N^{+}} \sum_{n=i-1}^{i+1} \sum_{m=j-1}^{j+1}
                       \delta_{\textrm{na}}(n,m) \delta_{\textrm{ice}}(n,m) \delta_1^{i,j}(n,m) \mathcal{I}[n,m] \\
                 &amp;- \frac{1}{N^{-}} \sum_{n=i-2}^{i+2} \sum_{m=j-2}^{j+2}
               \delta_{\textrm{na}}(n,m) \delta_{\textrm{ice}}(n,m) \delta_2^{i,j}(n,m) \mathcal{I}[n,m] 
\end{split}
\end{split}\]</div>
<p>with</p>
<div class="math notranslate nohighlight" id="equation-eq-laplace2">
<span class="eqno">(2)<a class="headerlink" href="#equation-eq-laplace2" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{aligned}
\delta_k^{i,j}(n,m) &amp; = &amp; \left\{ \begin{array}{ll} 1 &amp; \mbox{if $|i-n| = k$ or $|j-m| = k$};\\ \nonumber
             0 &amp; \mbox{otherwise}.\end{array} \right.   \\ \nonumber
N^{+} &amp;=&amp; \sum_{n=i-1}^{i+1} \sum_{m=j-1}^{j+1} \delta_{\textrm{na}}(n,m) \delta_{\textrm{ice}}(n,m) \delta_1^{i,j}(n,m)  \leq  8 \\ \nonumber
N^{-} &amp;=&amp; \sum_{n=i-2}^{i+2} \sum_{m=j-2}^{j+2} \delta_{\textrm{na}}(n,m) \delta_{\textrm{ice}}(n,m) \delta_2^{i,j}(n,m)  \leq  16 \nonumber
\end{aligned}
\end{split}\]</div>
<p>In Eq. <a class="reference internal" href="#equation-eq-laplace">(1)</a> and <a class="reference internal" href="#equation-eq-laplace2">(2)</a>, <span class="math notranslate nohighlight">\(\delta_{\textrm{na}}(n,m)\)</span> has value <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(\mathcal{I}[n,m]\)</span> is
non available (a missing value in the swath, or missing values outside the coverage of the swath) and
<span class="math notranslate nohighlight">\(\delta_{\textrm{ice}}(n,m)\)</span> is <span class="math notranslate nohighlight">\(1\)</span> only over ice pixels, as
specified by the ice/water/land mask. It means that only <em>valid</em>, <em>sea ice</em>
pixels enter the Laplacian field in order to limit spurious features
along the ice edge, coastline or at the border of the swath coverage.</p>
<p><span class="math notranslate nohighlight">\(\mathcal{L}[i,j]\)</span> is only computed if the centre cell <span class="math notranslate nohighlight">\([i,j]\)</span> is itself
over sea ice, <span class="math notranslate nohighlight">\(\delta_{\textrm{ice}}(i,j)=1\)</span>.</p>
<p>In the event when <span class="math notranslate nohighlight">\(N^{+} &lt; 5\)</span> or <span class="math notranslate nohighlight">\(N^{-} &lt; 9\)</span>, not enough pixels are
available for computing <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> and a missing value is stored at
grid cell <span class="math notranslate nohighlight">\([i,j]\)</span>.</p>
</section>
<section id="id6">
<h5>Input data<a class="headerlink" href="#id6" title="Permalink to this headline">#</a></h5>
<p>The remapped brightness temperatures on the image grids (16 2D fields).</p>
</section>
<section id="id7">
<h5>Output data<a class="headerlink" href="#id7" title="Permalink to this headline">#</a></h5>
<p>16 2D field of laplacian-filtered brightness temperature on the image grids.</p>
</section>
<section id="id8">
<h5>Ancillary data<a class="headerlink" href="#id8" title="Permalink to this headline">#</a></h5>
<p>The ice/water/land mask on the image grids.</p>
</section>
</section>
</section>
<section id="sea-ice-motion-tracking">
<h3>Sea-ice motion tracking<a class="headerlink" href="#sea-ice-motion-tracking" title="Permalink to this headline">#</a></h3>
<p>To compute sea-ice drift vectors require two images. A <em>start</em> and an <em>end</em> image. In the near-real-time Level-2 processing context, the end image is the (laplacian filtered) remapped imagery
from the input Level-1b file. Start images are taken from a running pool of remapped imagery from the previous runs of the sea-ice drift algorithm. In principle, many start images can be selected
and run into the sea-ice motion tracking against the end image. The difference between the valid time of the start and end imagery determines the drift duration (<em>aka</em> time span) of the Level-2
drift vectors.</p>
<p>At minimum (and in priority), the Level-2 sea-ice drift algorithm should be applied once with a start image with valid time approximately 24 hours before the valid time of the end image. This results in 24 hours drift vectors.
Ideally, the sea-ice motion tracking algorithm described below is applied for several (start, end) image pair to obtain a good temporal sampling of the sea-ice motion (e.g. 24 hours, 18 hours, 12 hours, 6 hours, etc…). At max,
the sea-ice motion tracking algorithm would be applied with all (start, end) image pairs for which the valid time of the start image is less or equal to 24 hours from the valid time of the end image. Each (start, end) image pair
will correspond to different area of intersect between the two swaths, and thus to different numbers of resulting sea-ice drift vectors. Pairs with too limited overlaps could be discarded up-front to favour processing pairs
with a large overlap. Because swath-to-swath motion tracking is very sensitive to (systematic) geolocation errors <span id="id9">[<a class="reference internal" href="references.html#id20" title="T. Lavergne, M. Piñol Solé, E. Down, and C. Donlon. Towards a swath-to-swath sea-ice drift product for the copernicus imaging microwave radiometer mission. The Cryosphere, 15(8):3681–3698, 2021. URL: https://tc.copernicus.org/articles/15/3681/2021/, doi:10.5194/tc-15-3681-2021.">Lavergne <em>et al.</em>, 2021</a>]</span> it might be preferrable to not process some pairs (e.g. ascending vs descending) that
would have larger uncertainties.</p>
<p>A hard limit is that the processing of all the image pairs must happen before the next input Level-1b input file is available for processing. Parallel computing strategy will help reduce the
total processing time (since each image pair can be processed independently from each others). A schedulding strategy must be designed to affort the maximum number of image pairs before it causes a problem for product latency.</p>
<p>At this stage it is TBD if each (start, end) image pairs results in individual Level-2 product files (better for the latency) or if all the sea-ice drift vectors (with different time spans) are concatenated in a single
Level-2 product file.</p>
<p>In any case, the description below is for a single (start, end) image pair, and for each image grid (nh and sh) separately.</p>
<section id="select-grid-locations-where-to-apply-the-cmcc-algorithm">
<h4>Select grid locations where to apply the CMCC algorithm<a class="headerlink" href="#select-grid-locations-where-to-apply-the-cmcc-algorithm" title="Permalink to this headline">#</a></h4>
<p>The CMCC can only be applied where the two swaths (start and end images) overlap over sea ice. A first step in the processing is thus to go through all the positions in the <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-250</span></code> grid and test if
there is sufficient overlap between the two images, and if the overlap is over sea ice.</p>
<section id="logical-description">
<h5>Logical description<a class="headerlink" href="#logical-description" title="Permalink to this headline">#</a></h5>
<p>For each grid position in the Level-2 product grid, the following tests are performed.</p>
<p>Masking of land pixel (step 1)</p>
<ul class="simple">
<li><p>Blocks whose centre pixel is over land are discarded;</p></li>
</ul>
<p>Masking of pixels with not enough sea ice (step 2)</p>
<ul class="simple">
<li><p>The start and end blocks of the two ice/water/land masks are loaded. Discard
the grid locations whose start and end blocks are not entirely over ice.</p></li>
</ul>
<p>Masking of pixels with missing data (step 3)</p>
<ul class="simple">
<li><p>The start and end blocks of the Laplacian images are loaded.
Discard the grid locations whose blocks hold missing data.</p></li>
</ul>
<p>The positions that are not discarded after those three steps are passed to the next processing step (CMCC).</p>
</section>
<section id="id10">
<h5>Input data<a class="headerlink" href="#id10" title="Permalink to this headline">#</a></h5>
<p>The two (start and end) ice/ocean/land masks on the image grid <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-005</span></code>.</p>
<p>The two (start and end) laplacian-filtered brightness temperature maps on the image grid <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-005</span></code>.</p>
<p>The diameter of the sub-image (<em>aka</em> image block) to be used in the CMCC, in number of pixels.</p>
<p>The definition of the Level-2 product grid <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-025</span></code>.</p>
</section>
<section id="id11">
<h5>Output data<a class="headerlink" href="#id11" title="Permalink to this headline">#</a></h5>
<p>A 2D field of status flags recording the status at the end of this selection step (in particular recording where and why CMCC will not be attempted).</p>
</section>
</section>
<section id="run-the-cmcc-algorithm">
<h4>Run the CMCC algorithm<a class="headerlink" href="#run-the-cmcc-algorithm" title="Permalink to this headline">#</a></h4>
<p>The CMCC is the core sea-ice motion algorithm</p>
<section id="id12">
<h5>Mathematical description<a class="headerlink" href="#id12" title="Permalink to this headline">#</a></h5>
<p>We note <span class="math notranslate nohighlight">\(\mathcal{L}_0(x,y)[i]\)</span> the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel of the <em>start</em>
sub-image centred at point <span class="math notranslate nohighlight">\((x,y)\)</span>, extracted from the <span class="math notranslate nohighlight">\(\mathcal{L}_0\)</span>
image. <span class="math notranslate nohighlight">\((x,y)\)</span> are the coordinates expressed in the underpinning EASE2
projection (units km).</p>
<p>The total number of pixels <span class="math notranslate nohighlight">\(N\)</span> in a sub-image depends on the diameter of the sub-image (input parameter).</p>
<p>The mean and standard deviation values for a given sub-image are:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\langle \mathcal{L}_0(x,y) \rangle &amp; = &amp; \frac{1}{N} \sum_{i=1}^{N} \mathcal{L}_0(x,y)[i] \nonumber \\
\sigma ( \mathcal{L}_0(x,y) ) &amp; = &amp; \sqrt{\langle \mathcal{L}^2_0(x,y) \rangle - \langle \mathcal{L}_0(x,y) \rangle^2}  \nonumber
\end{aligned}
\end{split}\]</div>
<p>Similar values can be computed for a <em>end</em> sub-image centred at
<span class="math notranslate nohighlight">\((u,v)\)</span>: <span class="math notranslate nohighlight">\(\langle \mathcal{L}_1(u,v) \rangle\)</span> and
<span class="math notranslate nohighlight">\(\sigma ( \mathcal{L}_1(u,v) )\)</span>.</p>
<p>The match between a start and a stop sub-image is evaluated via the correlation metric:</p>
<div class="math notranslate nohighlight" id="equation-eq-rho">
<span class="eqno">(3)<a class="headerlink" href="#equation-eq-rho" title="Permalink to this equation">#</a></span>\[
\rho(x,y,\delta_x,\delta_y) =
\frac{
\sum_{i=1}^{N} (\mathcal{L}_0(x,y)[i]-\langle \mathcal{L}_0(x,y) \rangle) (\mathcal{L}_1(x+\delta_x,y+\delta_y)[i]-\langle \mathcal{L}_1(x+\delta_x,y+\delta_y) \rangle)
}{\sigma ( \mathcal{L}_0(x,y) ) \sigma ( \mathcal{L}_1(x+\delta_x,y+\delta_y) )}
\]</div>
<p>By construction, <span class="math notranslate nohighlight">\(\rho(x,y,\delta_x,\delta_y)\)</span> takes
values between <span class="math notranslate nohighlight">\(-1\)</span> and <span class="math notranslate nohighlight">\(+1\)</span>. High values indicate a good match between
the sub-images. This is further interpreted as having found the offsets
<span class="math notranslate nohighlight">\(\delta_x = u - x\)</span> and <span class="math notranslate nohighlight">\(\delta_y = v - y\)</span> which best explain the local
change in intensity between the two sub-images. <span class="math notranslate nohighlight">\((\delta_x,\delta_y)\)</span> is
the drift vector.</p>
<p>Pixels of the candidate block <span class="math notranslate nohighlight">\(\mathcal{L}_1(x+\delta_x,y+\delta_y)\)</span> are
computed from bi-linear interpolations of the pixels of <span class="math notranslate nohighlight">\(\mathcal{L}_1\)</span>.
For example, <span class="math notranslate nohighlight">\(\mathcal{L}_1(u,v)[i]\)</span> is given by:</p>
<div class="math notranslate nohighlight" id="equation-eq-imginterp">
<span class="eqno">(4)<a class="headerlink" href="#equation-eq-imginterp" title="Permalink to this equation">#</a></span>\[\begin{split}
\begin{split}
\mathcal{L}_1(u,v)[i] &amp; = (1 - \epsilon_{u}) \times (1 - \epsilon_{v}) \times \mathcal{L}_1(\bar{u},\bar{v})[i] \\
        &amp;+  (1 - \epsilon_{u}) \times \epsilon_{v} \times  \mathcal{L}_1(\bar{u},\bar{v}+s_{v})[i] \\
        &amp;+ \epsilon_{u} \times (1 - \epsilon_{v}) \times  \mathcal{L}_1(\bar{u}+s_{u},\bar{v})[i] \\
        &amp;+ \epsilon_{u} \times \epsilon_{v} \times \mathcal{L}_1(\bar{u}+s_{u},\bar{v}+s_{v})[i]
\end{split}
\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\bar{t} &amp; = &amp; \operatorname{Trunc}(t) \\
\epsilon_t &amp; = &amp; |t - \bar{t}| \\
s_t        &amp; = &amp; \frac{t}{|t|}
\end{aligned}
\end{split}\]</div>
<p>For example, for <span class="math notranslate nohighlight">\(t=-2.8\)</span>, <span class="math notranslate nohighlight">\(\bar{t}=-2\)</span>, <span class="math notranslate nohighlight">\(\epsilon_t=0.8\)</span> and <span class="math notranslate nohighlight">\(s_t=-1\)</span>. Eq. <a class="reference internal" href="#equation-eq-imginterp">(4)</a> permits computing <em>virtual</em>
sub-images at continuously varying centre points <span class="math notranslate nohighlight">\((u,v)\)</span> and thus building a continuous optimisation framework to the estimation of motion
vectors from a pair of images.</p>
<p>Finding the motion vector <span class="math notranslate nohighlight">\((\delta_x,\delta_y)\)</span> at position <span class="math notranslate nohighlight">\((x,y)\)</span> can
be expressed as the following maximisation problem:</p>
<div class="math notranslate nohighlight" id="equation-eq-maximonech">
<span class="eqno">(5)<a class="headerlink" href="#equation-eq-maximonech" title="Permalink to this equation">#</a></span>\[
\max_{(x,y)\in\mathcal{D}} \rho(x,y,\delta_x,\delta_y)
\]</div>
<p>which is solved at all grid positions where the motion vector is searched for (see previous step). Each optimisation is conducted independently
from the others. <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> is a validity domain for <span class="math notranslate nohighlight">\((\delta_x,\delta_y)\)</span>. Eq. <a class="reference internal" href="#equation-eq-maximonech">(5)</a> thus defines a two dimensional optimisation
problem with domain constraint.</p>
<p>Eq. <a class="reference internal" href="#equation-eq-maximonech">(5)</a> is valid for one pair of images. In the CIMR sea-ice drift algorithm, we however envision not one pair of (start, end) images but 16 pairs
(fwd-fwd, fwd-bck, bck-fwd, and fwd-bck) for each of Ku-V, Ku-H, Ka-V, and Ka-H considering the foward and backward scans as separate images. Following <span id="id13">Lavergne <em>et al.</em> [<a class="reference internal" href="references.html#id19" title="Thomas Lavergne, Steinar Eastwood, Zakaria Teffah, Harald Schyberg, and Lars-Anders Breivik. Sea ice motion from low resolution satellite sensors: an alternative method and its validation in the Arctic. Journal of Geophysical Research, 2010. doi:10.1029/2009JC005958.">2010</a>]</span>
we implement an inplicit merging of the information content of the 16 imaging channels by maximizing a sum of cross-correlation functions:</p>
<div class="math notranslate nohighlight" id="equation-eq-maxim">
<span class="eqno">(6)<a class="headerlink" href="#equation-eq-maxim" title="Permalink to this equation">#</a></span>\[
\max_{(x,y)\in\mathcal{D}} \frac{1}{N_{ch}} \sum_{c=1}^{c=N_{ch}} \rho^{c}(x,y,\delta_x,\delta_y)
\]</div>
<p>where <span class="math notranslate nohighlight">\(N_{ch}\)</span> is the number of channels (<span class="math notranslate nohighlight">\(N_{ch} = 16\)</span>).</p>
<p>Eq. <a class="reference internal" href="#equation-eq-maxim">(6)</a> is solved by the Nelder Mead algorithm <span id="id14">[<a class="reference internal" href="references.html#id24" title="J. A. Nelder and R. Mead. A simplex method for function minimization. Computational Journal, 7:308–313, 1968.">Nelder and Mead, 1968</a>]</span>. This algorithm is
chosen since it is simple to implement and does not require computing the gradients of the function to be minimized. It furthermore has good convergence
and computational properties in problems with low dimensionality <span id="id15">[<a class="reference internal" href="references.html#id18" title="Jeffrey C. Lagarias, James A. Reeds, Margaret H. Wright, and Paul E. Wright. Convergence properties of the Nelder-Mead simplex method in low dimensions. SIAM Journal on Optimization, 9:112–147, 1998.">Lagarias <em>et al.</em>, 1998</a>]</span>.</p>
<p>Starting points for the optimisation are sampled on a length-angle regular grid around point <span class="math notranslate nohighlight">\((0,0)\)</span> as on <a class="reference internal" href="#fig-startpoints"><span class="std std-numref">Fig. 4</span></a>.</p>
<figure class="align-default" id="fig-startpoints">
<a class="reference internal image-reference" href="_images/CMCC_startpoints.png"><img alt="_images/CMCC_startpoints.png" src="_images/CMCC_startpoints.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Initialization points for the Nelder-Mead algorithm, chosen on a regular length-angle grid aroung point <span class="math notranslate nohighlight">\((0,0)\)</span>.</span><a class="headerlink" href="#fig-startpoints" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The length increment is set to <span class="math notranslate nohighlight">\(10\)</span>km and the angular increment to
<span class="math notranslate nohighlight">\(45^{\circ}\)</span>. The circle has radius <span class="math notranslate nohighlight">\(\mathbf{L}\)</span>, the maximum drift
distance defining <span class="math notranslate nohighlight">\(\mathcal{D}\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\rho(x,y,\delta_x,\delta_y)\)</span> is computed at each of those points and the best 3 vertexes are kept for initialising the Nelder-Mead
optimisation.</p>
<p>Termination and convergence is tested upon via a relative difference of function values at the current <em>best</em> and <em>worst</em> vertexes, <span class="math notranslate nohighlight">\(f_b\)</span> and
<span class="math notranslate nohighlight">\(f_w\)</span>. Specifically, the algorithm is said to have converged if and only if <span class="math notranslate nohighlight">\(| f_b - f_w | &lt; (f_b + f_w) \times \tau + \epsilon\)</span>, with <span class="math notranslate nohighlight">\(\tau\)</span> and
<span class="math notranslate nohighlight">\(\epsilon\)</span> small and positive floating point values. As a safeguard, the maximum number of iterations is set to 1000.</p>
<p>In Eq. <a class="reference internal" href="#equation-eq-maxim">(6)</a> <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> is a disc shaped domain expressing the <em>a-priori</em>
knowledge we bring to the optimisation problem. Its purpose is to limit
the search area for the solution vector during the optimisation process. It is defined by a centre point <span class="math notranslate nohighlight">\((x_c,y_c)\)</span> and radius <span class="math notranslate nohighlight">\(\mathbf{L}\)</span>.</p>
<div class="math notranslate nohighlight" id="equation-eq-domain">
<span class="eqno">(7)<a class="headerlink" href="#equation-eq-domain" title="Permalink to this equation">#</a></span>\[
(\delta_x,\delta_y) \in \mathcal{D}_{x_c,y_c} \Leftrightarrow d(x_c,y_c;\delta_x,\delta_y) &lt; \mathbf{L}
\]</div>
<p>In Eq. <a class="reference internal" href="#equation-eq-domain">(7)</a>, <span class="math notranslate nohighlight">\(d(x_c,y_c;\delta_x,\delta_y)\)</span> is the distance
(great circle) between the centre point of <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> and
the tip of the drift vector <span class="math notranslate nohighlight">\((\delta_x,\delta_y)\)</span>. <span class="math notranslate nohighlight">\((x_c,y_c)\)</span>
represents our best <em>a-priori</em> knowledge at the time of performing the
optimisation. It is initially set to <span class="math notranslate nohighlight">\((0,0)\)</span>.</p>
<p>Eq. <a class="reference internal" href="#equation-eq-domain">(7)</a> cannot be used <em>as is</em> in the optimisation routine since it leads to
abrupt and non-linear behaviour. <span class="math notranslate nohighlight">\(\mathcal{D}\)</span> is instead implemented as a <em>soft</em> constraint based on a
mono-dimensional sigmoid function <span class="math notranslate nohighlight">\(W(d)\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-eq-sigmoid">
<span class="eqno">(8)<a class="headerlink" href="#equation-eq-sigmoid" title="Permalink to this equation">#</a></span>\[
W(d)   = \frac{1}{1 + e^{k(d - \mathbf{L})}} 
\]</div>
<p>In Eq. <a class="reference internal" href="#equation-eq-sigmoid">(8)</a>, <span class="math notranslate nohighlight">\(k\)</span> is a parameter controlling the steepness
of the sigmoid around the cut-off value <span class="math notranslate nohighlight">\(\mathbf{L}\)</span>. By construction,
<span class="math notranslate nohighlight">\(W(\mathbf{L}) = 0.5\)</span>. By using a large enough value for <span class="math notranslate nohighlight">\(k\)</span>, the <span class="math notranslate nohighlight">\(W\)</span>
can be made arbitrarily close to the Heaviside step function, yet
remaining smooth and continuous.</p>
<p>Eq. <a class="reference internal" href="#equation-eq-penalising">(9)</a> illustrate how the penalty is applied to the correlation function
<span class="math notranslate nohighlight">\(\rho^c(x,y,\delta_x,\delta_y)\)</span> (Eq. <a class="reference internal" href="#equation-eq-maxim">(6)</a>).</p>
<div class="math notranslate nohighlight" id="equation-eq-penalising">
<span class="eqno">(9)<a class="headerlink" href="#equation-eq-penalising" title="Permalink to this equation">#</a></span>\[
\rho^c_D(x,y,\delta_x,\delta_y) = (\rho^c(x,y,\delta_x,\delta_y) + 1) \times W(d(x_c,y_c;\delta_x,\delta_y)) - 1
\]</div>
<p><a class="reference internal" href="#fig-sigmoids"><span class="std std-numref">Fig. 5</span></a> plots a mono-dimensional example of applying a sigmoid penalty function
to a synthetic correlation function. Evaluations for <span class="math notranslate nohighlight">\(x\)</span> lower than L
are dominated by the correlation value <span class="math notranslate nohighlight">\(\rho(x)\)</span> while those occurring
outside the domain (<span class="math notranslate nohighlight">\(x\)</span> larger than <span class="math notranslate nohighlight">\(L\)</span>) return very bad scores, that is
close to <span class="math notranslate nohighlight">\(-1\)</span>.</p>
<figure class="align-default" id="fig-sigmoids">
<a class="reference internal image-reference" href="_images/sigmoids.png"><img alt="_images/sigmoids.png" src="_images/sigmoids.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5 </span><span class="caption-text">Example soft constraint implemented with a sigmoid penalisation function <span class="math notranslate nohighlight">\(W\)</span> and its application on a synthetic,
mono-dimensional correlation signal <span class="math notranslate nohighlight">\(\rho\)</span>. Here, the <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> parameter is <span class="math notranslate nohighlight">\(1.3\)</span> and <span class="math notranslate nohighlight">\(k\)</span> is <span class="math notranslate nohighlight">\(20\)</span>.}</span><a class="headerlink" href="#fig-sigmoids" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>In Eq. <a class="reference internal" href="#equation-eq-penalising">(9)</a>, <span class="math notranslate nohighlight">\(\rho_D\)</span> is the penalised correlation function. Finding the maximum
of <span class="math notranslate nohighlight">\(\rho_D\)</span> is taken as a proxy for solving the original, constrained,
optimisation problem of Eq. <a class="reference internal" href="#equation-eq-maxim">(6)</a>. <span class="math notranslate nohighlight">\(\rho_D\)</span> is the function entering the Nelder-Mead
algorithm instead of <span class="math notranslate nohighlight">\(\rho\)</span>.</p>
<p>It is customary to compute <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> as a maximum expected speed
<span class="math notranslate nohighlight">\(v_{max}\)</span>, multiplied by the time separation between the valid times of the two images
<span class="math notranslate nohighlight">\(\mathbf{T}_1\)</span> - <span class="math notranslate nohighlight">\(\mathbf{T}_0\)</span>. <span class="math notranslate nohighlight">\(\mathbf{L}\)</span> is thus the maximum
expected straight-line distance that can be covered in the given time.</p>
</section>
<section id="id16">
<h5>Input data<a class="headerlink" href="#id16" title="Permalink to this headline">#</a></h5>
<p>The diameter of the sub-image (<em>aka</em> image block) to be used in the CMCC, in number of pixels.</p>
<p>The maximum allowed drift speed <span class="math notranslate nohighlight">\(v_{max}\)</span> (to define <span class="math notranslate nohighlight">\(\mathbf{L}\)</span>) and \mathcal{D}).</p>
<p>The 8 imagery bands for the start and end images, as well as the associated valid times <span class="math notranslate nohighlight">\(\mathbf{T}\)</span>.</p>
</section>
<section id="id17">
<h5>Output data<a class="headerlink" href="#id17" title="Permalink to this headline">#</a></h5>
<p>A 2D field of drift vectors (<span class="math notranslate nohighlight">\(\delta_x\)</span> and <span class="math notranslate nohighlight">\(\delta_y\)</span> components) on the <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-250</span></code> grid.</p>
<p>A 2D field of maximum cross-correlation value for each vector.</p>
<p>A 2D field of status flags recording the status at the end of the CMCC optimization.</p>
</section>
</section>
<section id="quality-control-detect-and-correct-outliers-rogue-vectors">
<h4>Quality Control: detect and correct outliers (“rogue” vectors)<a class="headerlink" href="#quality-control-detect-and-correct-outliers-rogue-vectors" title="Permalink to this headline">#</a></h4>
<p>Once the CMCC described above has been applied once to each of the
start positions selected by the preliminary checks, a filtering step
is taken to detect, correct or remove obviously erroneous vectors (so called “rogue” vectors).</p>
<p>Causes for those erroneous vectors include:</p>
<ol class="simple">
<li><p>convergence of the Nelder Mead algorithm in a local maximum;</p></li>
<li><p>noise in the sub-images;</p></li>
<li><p>edge effects in the sub-images.</p></li>
</ol>
<p>Whatever the reason be, the filtering step is based on the
distance from individual displacement vectors to the average of its
neighbouring vectors. If this distance is less than a fixed threshold,
the displacement vector being tested is validated and another vector is
tested upon. Otherwise, a new CMCC motion tracking optimisation is triggered.</p>
<p>In this new CMCC optimization, the Nelder Mead algorithm is initialised and run like in the previous
section, except that the validity domain <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> is adapted (center and radius) to translate the new constraint.</p>
<p>Erroneous vectors are detected and corrected one by one, from the “most erroneous” (see below) until
all vectors are either corrected or flagged as bad.</p>
<section id="id18">
<h5>Mathematical description<a class="headerlink" href="#id18" title="Permalink to this headline">#</a></h5>
<p>Let <span class="math notranslate nohighlight">\(\Delta_{\textrm{avg}}\)</span> be the distance between the tip of the
current drift vector <span class="math notranslate nohighlight">\((\delta_x,\delta_y)\)</span> and the tip of the zonal
average drift vector
<span class="math notranslate nohighlight">\((\delta^{\textrm{avg}}_x,\delta^{\textrm{avg}}_y)\)</span>. The average drift
vector is computed from the 8 neighbouring drift vectors, that is the 8
closest vectors <em>not including the current one</em>. The local <span class="math notranslate nohighlight">\(\mathbf{D}\)</span>
domain is then the disc with centre
<span class="math notranslate nohighlight">\((\delta^{\textrm{avg}}_x,\delta^{\textrm{avg}}_y)\)</span> and radius
<span class="math notranslate nohighlight">\(\Delta^{\textrm{avg}}_{\textrm{max}}\)</span>. <span class="math notranslate nohighlight">\(\Delta^{\textrm{avg}}_{\textrm{max}}\)</span> is set to <span class="math notranslate nohighlight">\(10\)</span>km.
Neighbouring vectors with a maximum correlation value of less than <span class="math notranslate nohighlight">\(0.5\)</span> are not
used, to avoid degrading the average drift field with possibly wrong
estimates.</p>
<figure class="align-default" id="fig-filter">
<a class="reference internal image-reference" href="_images/filter.png"><img alt="_images/filter.png" src="_images/filter.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">Example case where the current drift vector (in red) is obviously erroneous, considered the smoother vector field from the first estimate from
CMCC (in black). The locally averaged vector field is plotted in green. <span class="math notranslate nohighlight">\(\Delta^{\textrm{avg}}\)</span> is the length of the dashed red line.
The red disc has radius <span class="math notranslate nohighlight">\(\Delta^{\textrm{avg}}_{\textrm{max}}\)</span> and is the validity domain $\mathbf{D} that is used to re-optimise the drift vector.</span><a class="headerlink" href="#fig-filter" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-filter"><span class="std std-numref">Fig. 6</span></a> illustrates a typical case where a single erroneous vector is surrounded by a smooth vector field. Since the central estimate is not used in the
average, isolated wrong vectors stand out very easily in terms of their <span class="math notranslate nohighlight">\(\Delta_{\textrm{avg}}\)</span>.</p>
<p>During this second CMCC optimisation, the search for the maximum is limited to the area eclosed by the red circle. If a satisfying maximum
correlation is found inside <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> it is kept and the surrounding average vectors are immediately updated, as well as each
<span class="math notranslate nohighlight">\(\Delta_{\textrm{avg}}\)</span> lengths. If the constrained optimisation does not converge or if the new vector does not have a good enough maximum
correlation value, both the old and new vectors are discarded and the average vectors, as well as <span class="math notranslate nohighlight">\(\Delta_{\textrm{avg}}\)</span> at the neighbouring
locations are updated.</p>
<p>Although the method described above works in many cases, it sometimes fail when several erroneous vectors are close one to each other. This
happens especially when noise dominates the signal in a large region of one of the image. If the case, the order in which the vectors are
corrected has an influence on the final efficiency for the filtering.</p>
<p>To minimize this influence, motion vectors are first sorted from the largest to the shortest <span class="math notranslate nohighlight">\(\Delta_{\textrm{avg}}\)</span> and the filtering is
applied to the vector exhibiting the worst of those distances. Since, changing a vector has an influence on its direct neighbours, the sorting
is repeated after each correction. A mechanism is put in place to avoid falling into an infinite loop. This strategy also ensures that the good
vectors around an erroneous estimate are not modified before the latter is actually processed through the filter.</p>
<p>In the case where the new optimization does not lead to an acceptable maximum cross-correlation value (value below the threshold, non-convergence of the CMCC with the new contraint),
the vector position is recorded as non-feasible in the status flags, and the fields of drift vectors get a fill value.</p>
<p>This detection / correction process continues until all vectors are either corrected or flagged as non-feasible.</p>
</section>
<section id="id19">
<h5>Input data<a class="headerlink" href="#id19" title="Permalink to this headline">#</a></h5>
<p>The 2D field of drift vectors (<span class="math notranslate nohighlight">\(\delta_x\)</span> and <span class="math notranslate nohighlight">\(\delta_y\)</span> components) on the <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-250</span></code> grid from the initial CMCC run.</p>
<p>The 2D field of maximum cross-correlation value for each vector from the initial CMCC run.</p>
<p>The 2D field of status flags recording the status at the end of the initial CMCC optimization.</p>
</section>
<section id="id20">
<h5>Output data<a class="headerlink" href="#id20" title="Permalink to this headline">#</a></h5>
<p>Updates:</p>
<p>The 2D field of drift vectors (<span class="math notranslate nohighlight">\(\delta_x\)</span> and <span class="math notranslate nohighlight">\(\delta_y\)</span> components) on the <code class="docutils literal notranslate"><span class="pre">(n,s)h_ease2-250</span></code> grid from the initial CMCC run.</p>
<p>The 2D field of maximum cross-correlation value for each vector from the initial CMCC run.</p>
<p>The 2D field of status flags recording the status at the end of the initial CMCC optimization.</p>
</section>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="L2_product_definition.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Level-2 product definition</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="algorithm_input_output_data_definition.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Algorithm Input and Output Data Definition (IODD)</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Thomas Lavergne and Emily Down, Norwegian Meteorological Institute<br/>
  
    <div class="extra_footer">
      <p>
This ATBD was developed in the context of the ESA-funded CIMR DEVALGO study (2022-2024) (contract 4000137493).
<br>
ESA is not responsible in any way for the content of this document.
</p>

    </div>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>